{
  "BinarySearch": {
    "prefix": "BinarySearch",
    "body": [
      "/// Equivalent to std::lowerbound and std::upperbound in c++",
      "pub trait BinarySearch<T> {",
      "    fn lower_bound(&self, x: &T) -> usize;",
      "    fn upper_bound(&self, x: &T) -> usize;",
      "}",
      "impl<T: Ord> BinarySearch<T> for [T] {",
      "    fn lower_bound(&self, x: &T) -> usize {",
      "        let mut low = 0;",
      "        let mut high = self.len();",
      "        while low != high {",
      "            let mid = (low + high) / 2;",
      "            match self[mid].cmp(x) {",
      "                Ordering::Less => {",
      "                    low = mid + 1;",
      "                }",
      "                Ordering::Equal | Ordering::Greater => {",
      "                    high = mid;",
      "                }",
      "            }",
      "        }",
      "        low",
      "    }",
      "    fn upper_bound(&self, x: &T) -> usize {",
      "        let mut low = 0;",
      "        let mut high = self.len();",
      "        while low != high {",
      "            let mid = (low + high) / 2;",
      "            match self[mid].cmp(x) {",
      "                Ordering::Less | Ordering::Equal => {",
      "                    low = mid + 1;",
      "                }",
      "                Ordering::Greater => {",
      "                    high = mid;",
      "                }",
      "            }",
      "        }",
      "        low",
      "    }",
      "}"
    ]
  },
  "DSU": {
    "prefix": "DSU",
    "body": [
      "pub struct DSU {",
      "    p: Vec<i32>,",
      "}",
      "impl DSU {",
      "    pub fn new(n: usize) -> DSU {",
      "        assert!(n < std::i32::MAX as usize);",
      "        DSU { p: vec![-1; n] }",
      "    }",
      "    pub fn init(&mut self) {",
      "        self.p.iter_mut().for_each(|p| *p = -1);",
      "    }",
      "    pub fn root(&self, mut x: usize) -> usize {",
      "        assert!(x < self.p.len());",
      "        while self.p[x] >= 0 {",
      "            x = self.p[x] as usize;",
      "        }",
      "        x",
      "    }",
      "    pub fn same(&self, x: usize, y: usize) -> bool {",
      "        assert!(x < self.p.len() && y < self.p.len());",
      "        self.root(x) == self.root(y)",
      "    }",
      "    pub fn unite(&mut self, x: usize, y: usize) -> Option<(usize, usize)> {",
      "        assert!(x < self.p.len() && y < self.p.len());",
      "        let mut x = self.root(x);",
      "        let mut y = self.root(y);",
      "        if x == y {",
      "            return None;",
      "        }",
      "        if self.p[x] > self.p[y] {",
      "            std::mem::swap(&mut x, &mut y);",
      "        }",
      "        self.p[x] += self.p[y];",
      "        self.p[y] = x as i32;",
      "        Some((x, y))",
      "    }",
      "    pub fn parent(&self, x: usize) -> Option<usize> {",
      "        assert!(x < self.p.len());",
      "        let p = self.p[x];",
      "        if p >= 0 {",
      "            Some(p as usize)",
      "        } else {",
      "            None",
      "        }",
      "    }",
      "    pub fn sum<F>(&self, mut x: usize, mut f: F) -> usize",
      "    where",
      "        F: FnMut(usize),",
      "    {",
      "        while let Some(p) = self.parent(x) {",
      "            f(x);",
      "            x = p;",
      "        }",
      "        x",
      "    }",
      "    pub fn size(&self, x: usize) -> usize {",
      "        assert!(x < self.p.len());",
      "        let r = self.root(x);",
      "        (-self.p[r]) as usize",
      "    }",
      "}"
    ]
  },
  "Permutation": {
    "prefix": "Permutation",
    "body": [
      "pub struct PermutationIterator<T: Ord + Clone> {",
      "    li: Vec<T>,",
      "    is_finished: bool,",
      "}",
      "impl<T: Ord + Clone> PermutationIterator<T> {",
      "    pub fn new(mut li: Vec<T>) -> PermutationIterator<T> {",
      "        let is_finished = li.is_empty();",
      "        li.sort();",
      "        PermutationIterator { li, is_finished }",
      "    }",
      "}",
      "impl<T: Ord + Clone> Iterator for PermutationIterator<T> {",
      "    type Item = Vec<T>;",
      "    fn next(&mut self) -> Option<Self::Item> {",
      "        if self.is_finished {",
      "            return None;",
      "        }",
      "        if self.li.len() == 1 {",
      "            self.is_finished = true;",
      "            return Some(self.li.clone());",
      "        }",
      "        let mut i = self.li.len() - 1;",
      "        let res = self.li.clone();",
      "        loop {",
      "            let ii = i;",
      "            i -= 1;",
      "            if self.li[i] < self.li[ii] {",
      "                let mut j = self.li.len() - 1;",
      "                while self.li[i] >= self.li[j] {",
      "                    j -= 1;",
      "                }",
      "                self.li.swap(i, j);",
      "                self.li[ii..].reverse();",
      "                return Some(res);",
      "            }",
      "            if i == 0 {",
      "                self.li.reverse();",
      "                self.is_finished = true;",
      "                return Some(res);",
      "            }",
      "        }",
      "    }",
      "}",
      "pub trait Permutation<T: Ord + Clone> {",
      "    fn permutation(self) -> PermutationIterator<T>;",
      "}",
      "impl<T: Ord + Clone, I: IntoIterator<Item = T>> Permutation<T> for I {",
      "    fn permutation(self) -> PermutationIterator<T> {",
      "        PermutationIterator::new(self.into_iter().collect())",
      "    }",
      "}"
    ]
  }
}
