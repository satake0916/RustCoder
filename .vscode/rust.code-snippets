{
  "DSU": {
    "prefix": "DSU",
    "body": [
      "pub struct DSU {",
      "    p: Vec<i32>,",
      "}",
      "impl DSU {",
      "    pub fn new(n: usize) -> DSU {",
      "        assert!(n < std::i32::MAX as usize);",
      "        DSU { p: vec![-1; n] }",
      "    }",
      "    pub fn init(&mut self) {",
      "        self.p.iter_mut().for_each(|p| *p = -1);",
      "    }",
      "    pub fn root(&self, mut x: usize) -> usize {",
      "        assert!(x < self.p.len());",
      "        while self.p[x] >= 0 {",
      "            x = self.p[x] as usize;",
      "        }",
      "        x",
      "    }",
      "    pub fn same(&self, x: usize, y: usize) -> bool {",
      "        assert!(x < self.p.len() && y < self.p.len());",
      "        self.root(x) == self.root(y)",
      "    }",
      "    pub fn unite(&mut self, x: usize, y: usize) -> Option<(usize, usize)> {",
      "        assert!(x < self.p.len() && y < self.p.len());",
      "        let mut x = self.root(x);",
      "        let mut y = self.root(y);",
      "        if x == y {",
      "            return None;",
      "        }",
      "        if self.p[x] > self.p[y] {",
      "            std::mem::swap(&mut x, &mut y);",
      "        }",
      "        self.p[x] += self.p[y];",
      "        self.p[y] = x as i32;",
      "        Some((x, y))",
      "    }",
      "    pub fn parent(&self, x: usize) -> Option<usize> {",
      "        assert!(x < self.p.len());",
      "        let p = self.p[x];",
      "        if p >= 0 {",
      "            Some(p as usize)",
      "        } else {",
      "            None",
      "        }",
      "    }",
      "    pub fn sum<F>(&self, mut x: usize, mut f: F) -> usize",
      "    where",
      "        F: FnMut(usize),",
      "    {",
      "        while let Some(p) = self.parent(x) {",
      "            f(x);",
      "            x = p;",
      "        }",
      "        x",
      "    }",
      "    pub fn size(&self, x: usize) -> usize {",
      "        assert!(x < self.p.len());",
      "        let r = self.root(x);",
      "        (-self.p[r]) as usize",
      "    }",
      "}"
    ]
  },
  "enumerate_prime": {
    "prefix": "enumerate_prime",
    "body": [
      "fn enumerate_prime<F>(n: usize, mut f: F)",
      "where",
      "    F: FnMut(usize),",
      "{",
      "    assert!(1 <= n && n <= 5 * 10usize.pow(8));",
      "    let batch = (n as f64).sqrt().ceil() as usize;",
      "    let mut is_prime = vec![true; batch + 1];",
      "    for i in (2..).take_while(|p| p * p <= batch) {",
      "        if is_prime[i] {",
      "            let mut j = i * i;",
      "            while let Some(p) = is_prime.get_mut(j) {",
      "                *p = false;",
      "                j += i;",
      "            }",
      "        }",
      "    }",
      "    let mut prime = vec![];",
      "    for (i, p) in is_prime.iter().enumerate().skip(2) {",
      "        if *p && i <= n {",
      "            f(i);",
      "            prime.push(i);",
      "        }",
      "    }",
      "    let mut l = batch + 1;",
      "    while l <= n {",
      "        let r = std::cmp::min(l + batch, n + 1);",
      "        is_prime.clear();",
      "        is_prime.resize(r - l, true);",
      "        for &p in prime.iter() {",
      "            let mut j = (l + p - 1) / p * p - l;",
      "            while let Some(is_prime) = is_prime.get_mut(j) {",
      "                *is_prime = false;",
      "                j += p;",
      "            }",
      "        }",
      "        for (i, _) in is_prime.iter().enumerate().filter(|p| *p.1) {",
      "            f(i + l);",
      "        }",
      "        l += batch;",
      "    }",
      "}"
    ]
  },
  "run_length_encoding": {
    "prefix": "run_length_encoding",
    "body": [
      "fn run_length_encoding<T: Eq>(a: Vec<T>) -> Vec<(T, usize)> {",
      "    let mut a = a.into_iter().map(|a| (a, 1)).collect::<Vec<_>>();",
      "    a.dedup_by(|a, b| {",
      "        a.0 == b.0 && {",
      "            b.1 += a.1;",
      "            true",
      "        }",
      "    });",
      "    a",
      "}"
    ]
  }
}
