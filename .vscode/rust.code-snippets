{
  "DSU": {
    "prefix": "DSU",
    "body": [
      "pub struct DSU {",
      "    p: Vec<i32>,",
      "}",
      "impl DSU {",
      "    pub fn new(n: usize) -> DSU {",
      "        assert!(n < std::i32::MAX as usize);",
      "        DSU { p: vec![-1; n] }",
      "    }",
      "    pub fn init(&mut self) {",
      "        self.p.iter_mut().for_each(|p| *p = -1);",
      "    }",
      "    pub fn root(&self, mut x: usize) -> usize {",
      "        assert!(x < self.p.len());",
      "        while self.p[x] >= 0 {",
      "            x = self.p[x] as usize;",
      "        }",
      "        x",
      "    }",
      "    pub fn same(&self, x: usize, y: usize) -> bool {",
      "        assert!(x < self.p.len() && y < self.p.len());",
      "        self.root(x) == self.root(y)",
      "    }",
      "    pub fn unite(&mut self, x: usize, y: usize) -> Option<(usize, usize)> {",
      "        assert!(x < self.p.len() && y < self.p.len());",
      "        let mut x = self.root(x);",
      "        let mut y = self.root(y);",
      "        if x == y {",
      "            return None;",
      "        }",
      "        if self.p[x] > self.p[y] {",
      "            std::mem::swap(&mut x, &mut y);",
      "        }",
      "        self.p[x] += self.p[y];",
      "        self.p[y] = x as i32;",
      "        Some((x, y))",
      "    }",
      "    pub fn parent(&self, x: usize) -> Option<usize> {",
      "        assert!(x < self.p.len());",
      "        let p = self.p[x];",
      "        if p >= 0 {",
      "            Some(p as usize)",
      "        } else {",
      "            None",
      "        }",
      "    }",
      "    pub fn sum<F>(&self, mut x: usize, mut f: F) -> usize",
      "    where",
      "        F: FnMut(usize),",
      "    {",
      "        while let Some(p) = self.parent(x) {",
      "            f(x);",
      "            x = p;",
      "        }",
      "        x",
      "    }",
      "    pub fn size(&self, x: usize) -> usize {",
      "        assert!(x < self.p.len());",
      "        let r = self.root(x);",
      "        (-self.p[r]) as usize",
      "    }",
      "}"
    ]
  },
  "chminmax": {
    "prefix": "chminmax",
    "body": [
      "pub trait ChangeMinMax {",
      "    fn chmin(&mut self, x: Self) -> bool;",
      "    fn chmax(&mut self, x: Self) -> bool;",
      "}",
      "impl<T: PartialOrd> ChangeMinMax for T {",
      "    fn chmin(&mut self, x: Self) -> bool {",
      "        *self > x && {",
      "            *self = x;",
      "            true",
      "        }",
      "    }",
      "    fn chmax(&mut self, x: Self) -> bool {",
      "        *self < x && {",
      "            *self = x;",
      "            true",
      "        }",
      "    }",
      "}"
    ]
  },
  "enumerate_prime": {
    "prefix": "enumerate_prime",
    "body": [
      "fn enumerate_prime<F>(n: usize, mut f: F)",
      "where",
      "    F: FnMut(usize),",
      "{",
      "    assert!(1 <= n && n <= 5 * 10usize.pow(8));",
      "    let batch = (n as f64).sqrt().ceil() as usize;",
      "    let mut is_prime = vec![true; batch + 1];",
      "    for i in (2..).take_while(|p| p * p <= batch) {",
      "        if is_prime[i] {",
      "            let mut j = i * i;",
      "            while let Some(p) = is_prime.get_mut(j) {",
      "                *p = false;",
      "                j += i;",
      "            }",
      "        }",
      "    }",
      "    let mut prime = vec![];",
      "    for (i, p) in is_prime.iter().enumerate().skip(2) {",
      "        if *p && i <= n {",
      "            f(i);",
      "            prime.push(i);",
      "        }",
      "    }",
      "    let mut l = batch + 1;",
      "    while l <= n {",
      "        let r = std::cmp::min(l + batch, n + 1);",
      "        is_prime.clear();",
      "        is_prime.resize(r - l, true);",
      "        for &p in prime.iter() {",
      "            let mut j = (l + p - 1) / p * p - l;",
      "            while let Some(is_prime) = is_prime.get_mut(j) {",
      "                *is_prime = false;",
      "                j += p;",
      "            }",
      "        }",
      "        for (i, _) in is_prime.iter().enumerate().filter(|p| *p.1) {",
      "            f(i + l);",
      "        }",
      "        l += batch;",
      "    }",
      "}"
    ]
  },
  "modint": {
    "prefix": "modint",
    "body": [
      "mod modint {",
      "    #[allow(dead_code)]",
      "    pub struct Mod;",
      "    impl ConstantModulo for Mod {",
      "        const MOD: u32 = 998_244_353;",
      "    }",
      "    #[allow(dead_code)]",
      "    pub struct StaticMod;",
      "    static mut STATIC_MOD: u32 = 0;",
      "    impl Modulo for StaticMod {",
      "        fn modulo() -> u32 {",
      "            unsafe { STATIC_MOD }",
      "        }",
      "    }",
      "    #[allow(dead_code)]",
      "    impl StaticMod {",
      "        pub fn set_modulo(p: u32) {",
      "            unsafe {",
      "                STATIC_MOD = p;",
      "            }",
      "        }",
      "    }",
      "    use std::marker::*;",
      "    use std::ops::*;",
      "    pub trait Modulo {",
      "        fn modulo() -> u32;",
      "    }",
      "    pub trait ConstantModulo {",
      "        const MOD: u32;",
      "    }",
      "    impl<T> Modulo for T",
      "    where",
      "        T: ConstantModulo,",
      "    {",
      "        fn modulo() -> u32 {",
      "            T::MOD",
      "        }",
      "    }",
      "    pub struct ModInt<T>(pub u32, PhantomData<T>);",
      "    impl<T> Clone for ModInt<T> {",
      "        fn clone(&self) -> Self {",
      "            ModInt::new_unchecked(self.0)",
      "        }",
      "    }",
      "    impl<T> Copy for ModInt<T> {}",
      "    impl<T: Modulo> Add for ModInt<T> {",
      "        type Output = ModInt<T>;",
      "        fn add(self, rhs: Self) -> Self::Output {",
      "            let mut d = self.0 + rhs.0;",
      "            if d >= T::modulo() {",
      "                d -= T::modulo();",
      "            }",
      "            ModInt::new_unchecked(d)",
      "        }",
      "    }",
      "    impl<T: Modulo> AddAssign for ModInt<T> {",
      "        fn add_assign(&mut self, rhs: Self) {",
      "            *self = *self + rhs;",
      "        }",
      "    }",
      "    impl<T: Modulo> Sub for ModInt<T> {",
      "        type Output = ModInt<T>;",
      "        fn sub(self, rhs: Self) -> Self::Output {",
      "            let mut d = self.0 - rhs.0;",
      "            if d >= T::modulo() {",
      "                d += T::modulo();",
      "            }",
      "            ModInt::new_unchecked(d)",
      "        }",
      "    }",
      "    impl<T: Modulo> SubAssign for ModInt<T> {",
      "        fn sub_assign(&mut self, rhs: Self) {",
      "            *self = *self - rhs;",
      "        }",
      "    }",
      "    impl<T: Modulo> Mul for ModInt<T> {",
      "        type Output = ModInt<T>;",
      "        fn mul(self, rhs: Self) -> Self::Output {",
      "            let v = self.0 as u64 * rhs.0 as u64 % T::modulo() as u64;",
      "            ModInt::new_unchecked(v as u32)",
      "        }",
      "    }",
      "    impl<T: Modulo> MulAssign for ModInt<T> {",
      "        fn mul_assign(&mut self, rhs: Self) {",
      "            *self = *self * rhs;",
      "        }",
      "    }",
      "    impl<T: Modulo> Neg for ModInt<T> {",
      "        type Output = ModInt<T>;",
      "        fn neg(self) -> Self::Output {",
      "            if self.0 == 0 {",
      "                Self::zero()",
      "            } else {",
      "                Self::new_unchecked(T::modulo() - self.0)",
      "            }",
      "        }",
      "    }",
      "    impl<T> std::fmt::Display for ModInt<T> {",
      "        fn fmt<'a>(&self, f: &mut std::fmt::Formatter<'a>) -> std::fmt::Result {",
      "            write!(f, \"{}\", self.0)",
      "        }",
      "    }",
      "    impl<T> std::fmt::Debug for ModInt<T> {",
      "        fn fmt<'a>(&self, f: &mut std::fmt::Formatter<'a>) -> std::fmt::Result {",
      "            write!(f, \"{}\", self.0)",
      "        }",
      "    }",
      "    impl<T: Modulo> std::str::FromStr for ModInt<T> {",
      "        type Err = std::num::ParseIntError;",
      "        fn from_str(s: &str) -> Result<Self, Self::Err> {",
      "            let val = s.parse::<u32>()?;",
      "            Ok(ModInt::new(val))",
      "        }",
      "    }",
      "    impl<T: Modulo> From<usize> for ModInt<T> {",
      "        fn from(val: usize) -> ModInt<T> {",
      "            ModInt::new_unchecked((val % T::modulo() as usize) as u32)",
      "        }",
      "    }",
      "    impl<T: Modulo> From<u64> for ModInt<T> {",
      "        fn from(val: u64) -> ModInt<T> {",
      "            ModInt::new_unchecked((val % T::modulo() as u64) as u32)",
      "        }",
      "    }",
      "    impl<T: Modulo> From<i64> for ModInt<T> {",
      "        fn from(val: i64) -> ModInt<T> {",
      "            let m = T::modulo() as i64;",
      "            ModInt::new((val % m + m) as u32)",
      "        }",
      "    }",
      "    #[allow(dead_code)]",
      "    impl<T> ModInt<T> {",
      "        pub fn new_unchecked(d: u32) -> Self {",
      "            ModInt(d, PhantomData)",
      "        }",
      "        pub fn zero() -> Self {",
      "            ModInt::new_unchecked(0)",
      "        }",
      "        pub fn one() -> Self {",
      "            ModInt::new_unchecked(1)",
      "        }",
      "        pub fn is_zero(&self) -> bool {",
      "            self.0 == 0",
      "        }",
      "    }",
      "    #[allow(dead_code)]",
      "    impl<T: Modulo> ModInt<T> {",
      "        pub fn new(d: u32) -> Self {",
      "            ModInt::new_unchecked(d % T::modulo())",
      "        }",
      "        pub fn pow(&self, mut n: u64) -> Self {",
      "            let mut t = Self::one();",
      "            let mut s = *self;",
      "            while n > 0 {",
      "                if n & 1 == 1 {",
      "                    t *= s;",
      "                }",
      "                s *= s;",
      "                n >>= 1;",
      "            }",
      "            t",
      "        }",
      "        pub fn inv(&self) -> Self {",
      "            assert!(self.0 != 0);",
      "            self.pow(T::modulo() as u64 - 2)",
      "        }",
      "    }",
      "}"
    ]
  },
  "precalc": {
    "prefix": "precalc",
    "body": [
      "mod precalc {",
      "    use super::modint::*;",
      "    #[allow(dead_code)]",
      "    pub struct Precalc<T> {",
      "        inv: Vec<ModInt<T>>,",
      "        fact: Vec<ModInt<T>>,",
      "        ifact: Vec<ModInt<T>>,",
      "    }",
      "    #[allow(dead_code)]",
      "    impl<T: Modulo> Precalc<T> {",
      "        pub fn new(n: usize) -> Precalc<T> {",
      "            let mut inv = vec![ModInt::one(); n + 1];",
      "            let mut fact = vec![ModInt::one(); n + 1];",
      "            let mut ifact = vec![ModInt::one(); n + 1];",
      "            for i in 2..(n + 1) {",
      "                fact[i] = fact[i - 1] * ModInt::new_unchecked(i as u32);",
      "            }",
      "            ifact[n] = fact[n].inv();",
      "            if n > 0 {",
      "                inv[n] = ifact[n] * fact[n - 1];",
      "            }",
      "            for i in (1..n).rev() {",
      "                ifact[i] = ifact[i + 1] * ModInt::new_unchecked((i + 1) as u32);",
      "                inv[i] = ifact[i] * fact[i - 1];",
      "            }",
      "            Precalc {",
      "                inv: inv,",
      "                fact: fact,",
      "                ifact: ifact,",
      "            }",
      "        }",
      "        pub fn inv(&self, n: usize) -> ModInt<T> {",
      "            assert!(n > 0);",
      "            self.inv[n]",
      "        }",
      "        pub fn fact(&self, n: usize) -> ModInt<T> {",
      "            self.fact[n]",
      "        }",
      "        pub fn ifact(&self, n: usize) -> ModInt<T> {",
      "            self.ifact[n]",
      "        }",
      "        pub fn perm(&self, n: usize, k: usize) -> ModInt<T> {",
      "            if k > n {",
      "                return ModInt::zero();",
      "            }",
      "            self.fact[n] * self.ifact[n - k]",
      "        }",
      "        pub fn comb(&self, n: usize, k: usize) -> ModInt<T> {",
      "            if k > n {",
      "                return ModInt::zero();",
      "            }",
      "            self.fact[n] * self.ifact[k] * self.ifact[n - k]",
      "        }",
      "    }",
      "}"
    ]
  },
  "run_length_encoding": {
    "prefix": "run_length_encoding",
    "body": [
      "fn run_length_encoding<T: Eq>(a: Vec<T>) -> Vec<(T, usize)> {",
      "    let mut a = a.into_iter().map(|a| (a, 1)).collect::<Vec<_>>();",
      "    a.dedup_by(|a, b| {",
      "        a.0 == b.0 && {",
      "            b.1 += a.1;",
      "            true",
      "        }",
      "    });",
      "    a",
      "}"
    ]
  }
}
